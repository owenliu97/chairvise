{"remainingRequest":"C:\\Users\\Liu Ruiping\\Documents\\course-profile-mcomp\\proj\\chairvise3-0-final\\src\\web\\app\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\Liu Ruiping\\Documents\\course-profile-mcomp\\proj\\chairvise3-0-final\\src\\web\\app\\node_modules\\eslint-loader\\index.js??ref--13-0!C:\\Users\\Liu Ruiping\\Documents\\course-profile-mcomp\\proj\\chairvise3-0-final\\src\\web\\app\\src\\store\\helpers\\processor.js","dependencies":[{"path":"C:\\Users\\Liu Ruiping\\Documents\\course-profile-mcomp\\proj\\chairvise3-0-final\\src\\web\\app\\src\\store\\helpers\\processor.js","mtime":1573697856000},{"path":"C:\\Users\\Liu Ruiping\\Documents\\course-profile-mcomp\\proj\\chairvise3-0-final\\src\\web\\app\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\Liu Ruiping\\Documents\\course-profile-mcomp\\proj\\chairvise3-0-final\\src\\web\\app\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"C:\\Users\\Liu Ruiping\\Documents\\course-profile-mcomp\\proj\\chairvise3-0-final\\src\\web\\app\\node_modules\\eslint-loader\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es7.array.includes\";\nimport \"core-js/modules/es6.string.includes\";\nimport \"core-js/modules/es6.regexp.split\";\nimport moment from 'moment';\n\nfunction processDouble(raw) {\n  if (!isNaN(parseFloat(raw))) {\n    return parseFloat(raw);\n  } // if not even string, return default value 0\n\n\n  if (typeof raw !== \"string\") {\n    return 0;\n  } // TODO: figure out a better way to parse confidence level\n  // below is a hack\n\n\n  var rawStringList = raw.toLocaleLowerCase().split(\"\\n\");\n\n  for (var i = 0; i < rawStringList.length; i++) {\n    var rawString = rawStringList[i];\n\n    if (rawString.includes(\"confidence:\")) {\n      // hard code the processing\n      var confidenceValueString = rawString.trim().split(\":\")[1];\n      return parseFloat(confidenceValueString);\n    }\n  }\n\n  return 0;\n} // This is a rather complex function\n// this function includes some parsing logic\n\n\nexport function processMapping(mapping, data, dbFields, hasLabel) {\n  // validate\n  var checkDateResult = dateCheck(mapping, dbFields);\n\n  if (hasLabel) {\n    data = data.slice(1);\n  }\n\n  if (checkDateResult !== undefined) {\n    throw checkDateResult;\n  }\n\n  var result = [];\n  var map = {};\n\n  for (var i = 0; i < mapping.length; i++) {\n    map[mapping[i][0]] = mapping[mapping[i][1]];\n  }\n\n  var dateField;\n\n  for (var idx in dbFields.fieldMetaDataList) {\n    if (dbFields.fieldMetaDataList[idx].type === \"Date\") {\n      dateField = dbFields.fieldMetaDataList[idx].jsonProperty;\n    }\n  } // for each row of data\n\n\n  for (var _i = 0; _i < data.length; _i++) {\n    var row = data[_i];\n    var dataObject = {};\n    var usingDate = false;\n    var isSeparateDate = false;\n    var localDate = null,\n        localTime = null; // for each mapped database fields\n\n    for (var _idx in mapping) {\n      var rawData = row[mapping[_idx][1]];\n      var fieldType = dbFields.fieldMetaDataList[mapping[_idx][0]].type; // if date is selected, directly parse date as usual\n\n      if (fieldType === \"Date\") {\n        // TODO let user specify the format of the date instead of hardcoding\n        rawData = moment(rawData, \"YYYY-M-D H:m\").format(\"YYYY-MM-DD hh:mm:ss\");\n\n        if (rawData === \"Invalid date\") {\n          throw \"invalid date format\";\n        }\n\n        usingDate = true;\n        isSeparateDate = false;\n      } // if we are not using date and date time is not complete,\n      // then store local date\n\n\n      if (!usingDate && fieldType === \"LocalDate\" && localTime == null) {\n        localDate = rawData;\n        continue;\n      } // similarly, store local time\n\n\n      if (!usingDate && fieldType === \"LocalTime\" && localDate === null) {\n        localTime = rawData;\n        continue;\n      } // then if date is complete, combine then together\n\n\n      if (!usingDate && fieldType === \"LocalDate\" && localTime !== null) {\n        rawData = moment(rawData + \" \" + localTime, \"YYYY-M-D H:m\").format(\"YYYY-MM-DD hh:mm:ss\");\n\n        if (rawData === \"Invalid date\") {\n          throw \"invalid date format\";\n        }\n\n        isSeparateDate = true;\n      }\n\n      if (!usingDate && fieldType === \"LocalTime\" && localDate !== null) {\n        rawData = moment(localDate + \" \" + rawData, \"YYYY-M-D H:m\").format(\"YYYY-MM-DD hh:mm:ss\");\n\n        if (rawData === \"Invalid date\") {\n          throw \"invalid date format\";\n        }\n\n        isSeparateDate = true;\n      } // parse integer\n\n\n      if (fieldType === \"int\") {\n        rawData = parseInt(rawData);\n      } // parse double\n\n\n      if (fieldType === \"double\") {\n        rawData = processDouble(rawData);\n      } // parse authors\n\n\n      if (fieldType === \"List\") {\n        var dataList = rawData.split(\"and\");\n\n        if (dataList.length === 1) {\n          rawData = dataList;\n        } else {\n          var lastAuthor = dataList[1];\n          var allAuthors = dataList[0].split(\",\");\n          allAuthors.push(lastAuthor);\n          rawData = allAuthors;\n        }\n\n        rawData = rawData.map(function (author) {\n          return author.trim();\n        }); //console.log(rawData);\n\n        var convertstring = require(\"convert-string\");\n\n        for (var key in rawData) {\n          var author = rawData[key];\n          var name = author.split(\" \");\n          var concatname = \"\";\n\n          for (var itemkey in name) {\n            var conv = convertstring.stringToBytes(name[itemkey]);\n            var itemconv = \"\";\n\n            for (var a = 0; a < conv.length; a++) {\n              itemconv = itemconv.concat(String(conv[a] + 18));\n            }\n\n            name[itemkey] = itemconv;\n            concatname = concatname.concat(itemconv);\n            concatname = concatname.concat(\" \");\n          } //concatname.trim();\n          //console.log(concatname);\n\n\n          rawData[key] = concatname;\n        }\n\n        rawData = rawData.map(function (author) {\n          return author.trim();\n        }); //console.log(rawData);\n      } // if is separate date format, assign using date field\n      // else, assign directly using date field\n\n\n      if (isSeparateDate) {\n        dataObject[dateField] = rawData;\n        isSeparateDate = false;\n      } else {\n        dataObject[dbFields.fieldMetaDataList[mapping[_idx][0]].jsonProperty] = rawData;\n      }\n    }\n\n    result.push(dataObject);\n  }\n\n  return result;\n}\nexport function dateCheck(mapping, dbFields) {\n  var localDateExists = false;\n  var localTimeExists = false;\n\n  for (var idx in mapping) {\n    var dbLabelType = dbFields.fieldMetaDataList[mapping[idx][0]].type;\n\n    if (dbLabelType === \"Date\") {\n      return;\n    }\n\n    if (dbLabelType === \"LocalDate\") {\n      localDateExists = true;\n    }\n\n    if (dbLabelType === \"LocalTime\") {\n      localTimeExists = true;\n    }\n  }\n\n  if (localDateExists && !localTimeExists) {\n    return \"local time not specified when local date exists.\";\n  }\n\n  if (!localDateExists && localTimeExists) {\n    return \"local date not specified when local time exists.\";\n  }\n}",{"version":3,"sources":["C:/Users/Liu Ruiping/Documents/course-profile-mcomp/proj/chairvise3-0-final/src/web/app/src/store/helpers/processor.js"],"names":["moment","processDouble","raw","isNaN","parseFloat","rawStringList","toLocaleLowerCase","split","i","length","rawString","includes","confidenceValueString","trim","processMapping","mapping","data","dbFields","hasLabel","checkDateResult","dateCheck","slice","undefined","result","map","dateField","idx","fieldMetaDataList","type","jsonProperty","row","dataObject","usingDate","isSeparateDate","localDate","localTime","rawData","fieldType","format","parseInt","dataList","lastAuthor","allAuthors","push","author","convertstring","require","key","name","concatname","itemkey","conv","stringToBytes","itemconv","a","concat","String","localDateExists","localTimeExists","dbLabelType"],"mappings":"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","sourcesContent":["import moment from 'moment';\n\nfunction processDouble(raw) {\n  if (!isNaN(parseFloat(raw))) {\n    return parseFloat(raw);\n  }\n  // if not even string, return default value 0\n  if (typeof(raw) !== \"string\") {\n    return 0;\n  }\n\n  // TODO: figure out a better way to parse confidence level\n  // below is a hack\n  let rawStringList = raw.toLocaleLowerCase().split(\"\\n\");\n  for (let i = 0; i < rawStringList.length; i++) {\n    let rawString = rawStringList[i];\n    if (rawString.includes(\"confidence:\")) {\n      // hard code the processing\n      let confidenceValueString = rawString.trim().split(\":\")[1];\n      return parseFloat(confidenceValueString);\n    }\n  }\n  return 0;\n}\n\n// This is a rather complex function\n// this function includes some parsing logic\nexport function processMapping(mapping, data, dbFields, hasLabel) {\n  // validate\n  let checkDateResult = dateCheck(mapping, dbFields);\n  if (hasLabel) {\n    data = data.slice(1);\n  }\n  if (checkDateResult !== undefined) {\n    throw checkDateResult;\n  }\n  let result = [];\n  let map = {};\n  for (let i = 0; i < mapping.length; i++) {\n    map[mapping[i][0]] = mapping[mapping[i][1]]\n  }\n  let dateField;\n  for (let idx in dbFields.fieldMetaDataList) {\n    if (dbFields.fieldMetaDataList[idx].type === \"Date\") {\n      dateField = dbFields.fieldMetaDataList[idx].jsonProperty\n    }\n  }\n  // for each row of data\n  for (let i = 0; i < data.length; i++) {\n    let row = data[i];\n    let dataObject = {};\n\n    let usingDate = false;\n    let isSeparateDate = false;\n    let localDate = null, localTime = null;\n    // for each mapped database fields\n    for (let idx in mapping) {\n      let rawData = row[mapping[idx][1]];\n      let fieldType = dbFields.fieldMetaDataList[mapping[idx][0]].type;\n\n      // if date is selected, directly parse date as usual\n      if (fieldType === \"Date\") {\n        // TODO let user specify the format of the date instead of hardcoding\n        rawData = moment(rawData, \"YYYY-M-D H:m\").format(\"YYYY-MM-DD hh:mm:ss\");\n        if (rawData === \"Invalid date\") {\n          throw \"invalid date format\";\n        }\n        usingDate = true;\n        isSeparateDate = false;\n      }\n\n      // if we are not using date and date time is not complete,\n      // then store local date\n      if (!usingDate && fieldType === \"LocalDate\" && localTime == null) {\n        localDate = rawData;\n        continue;\n      }\n\n      // similarly, store local time\n      if (!usingDate && fieldType === \"LocalTime\" && localDate === null) {\n        localTime = rawData;\n        continue;\n      }\n\n      // then if date is complete, combine then together\n      if (!usingDate && fieldType === \"LocalDate\" && localTime !== null) {\n        rawData = moment(rawData + \" \" + localTime, \"YYYY-M-D H:m\").format(\"YYYY-MM-DD hh:mm:ss\");\n        if (rawData === \"Invalid date\") {\n          throw \"invalid date format\";\n        }\n        isSeparateDate = true;\n      }\n\n      if (!usingDate && fieldType === \"LocalTime\" && localDate !== null) {\n        rawData = moment(localDate + \" \" + rawData, \"YYYY-M-D H:m\").format(\"YYYY-MM-DD hh:mm:ss\");\n        if (rawData === \"Invalid date\") {\n          throw \"invalid date format\";\n        }\n        isSeparateDate = true;\n      }\n\n      // parse integer\n      if (fieldType === \"int\") {\n        rawData = parseInt(rawData);\n      }\n\n      // parse double\n      if (fieldType === \"double\") {\n        rawData = processDouble(rawData);\n      }\n\n      // parse authors\n      if (fieldType === \"List\") {\n        let dataList = rawData.split(\"and\");\n        if (dataList.length === 1) {\n          rawData = dataList;\n        } else {\n          let lastAuthor = dataList[1];\n          let allAuthors = dataList[0].split(\",\");\n          allAuthors.push(lastAuthor);\n          rawData = allAuthors;\n        }\n        rawData = rawData.map(author => author.trim());\n        //console.log(rawData);\n\n\n\n        var convertstring=require(\"convert-string\");\n        for (var key in rawData){\n            var author=rawData[key];\n            let name=author.split(\" \");\n            var concatname=\"\";\n            for (var itemkey in name){\n                var conv=convertstring.stringToBytes(name[itemkey]);\n                var itemconv=\"\";\n                for(var a=0;a<conv.length;a++){\n                    itemconv=itemconv.concat(String(conv[a]+18));\n                }\n                name[itemkey]=itemconv;\n                concatname=concatname.concat(itemconv);\n                concatname=concatname.concat(\" \");\n            }\n            //concatname.trim();\n            //console.log(concatname);\n            rawData[key]=concatname;\n         }\n         rawData = rawData.map(author => author.trim());\n\n         //console.log(rawData);\n\n      }\n\n      // if is separate date format, assign using date field\n      // else, assign directly using date field\n      if (isSeparateDate) {\n        dataObject[dateField] = rawData;\n        isSeparateDate = false;\n      } else {\n        dataObject[dbFields.fieldMetaDataList[mapping[idx][0]].jsonProperty] = rawData;\n      }\n    }\n    result.push(dataObject);\n  }\n  return result;\n}\n\nexport function dateCheck(mapping, dbFields) {\n  let localDateExists = false;\n  let localTimeExists = false;\n  for (let idx in mapping) {\n    let dbLabelType = dbFields.fieldMetaDataList[mapping[idx][0]].type;\n    if (dbLabelType === \"Date\") {\n      return;\n    }\n    if (dbLabelType === \"LocalDate\") {\n      localDateExists = true;\n    }\n    if (dbLabelType === \"LocalTime\") {\n      localTimeExists = true;\n    }\n  }\n  if (localDateExists && !localTimeExists) {\n    return \"local time not specified when local date exists.\"\n  }\n\n  if (!localDateExists && localTimeExists) {\n    return \"local date not specified when local time exists.\"\n  }\n}"]}]}